/**
 * Created by Andrew on 4/5/17.
 */
/**
 * This is our quadratic probing hash table.
 * This class contains an inner hash table represented by an array that has a standard hasing function (value % size)
 * and will 'probe forward' looking for a place to insert or find a value by incrementing the power index (i) by one degree  and checking
 * the value stored at the index generated by our hash function plus i*i until  an empty array position is found or the
 * value is found repsectively, or the index would exceed the array
 */
public class QuadraticProbingHashTable {
    //this reflects the size of the inner has table (number of elements we've allocated for)
    int size;
    //this is our member variable that represents the number of collisions
    int numberOfCollisions;
    //this is our inner hash table

    Integer[] hashTable;

    /**
     * This is our getter for our number of collisions
     * @return the number of collisions
     */
    public int getNumberOfCollisions() {
        return numberOfCollisions;
    }


    /**
     * This is our constructor. Create a hashtable or the given size
     * @param size the size of our hash table
     */
    public QuadraticProbingHashTable(int size){
        this.size=size; //set the size
        this.hashTable = new Integer[size]; //create the inner hashtable
        this.numberOfCollisions=0; // set number of collisions to 0
    }

    /**
     * This is our hashing function. We want to return an int index between 0 and size-1, so we do value modulo size
     * @param value the value to hash
     * @return int the hash key
     */
    public int hash(Integer value){
        int hash = value % size;
        return hash;
    }

    /**
     * This method allows us to insert into the hash table by inserting the value at the hashed index
     * @param value the value we want to insert into the hash table
     */
    public void insert(int value){
        //basically get the starting index from the hash value
        int index = this.hash(value);
        //then iterate till we reach the end OR till we find an empty position by increasing i, and checking to see if
        //[indexi*i] is null or not
        int i = 0;
        while(index+((i+1)*(i+1)) < this.size-1 && this.hashTable[index+(i*i)] != null){
            this.numberOfCollisions++;
            i++;

        }
        //set the value
        this.hashTable[index+(i*i)]=value;


    }

    /**
     * Retrieve a value from our hash table by getting the key and calling the linked list search funciton on the linked list
     * at that index
     * @param value the value to search for
     * @return int the index of the value?
     */
    //todo ask fox what to return here
    public int search(int value){
        //basically we want to probe forward until we find either hte element
        // or while the element we are looking at is not the element we want until we reach the end
        //basically get the starting index from the hash value
        int index = this.hash(value);
        //then iterate till we reach the end OR till we find an empty position
        int i = 0; //this is our power incrementor, just i*i
        //basically, the +1 part is to make sure that we don't iterate and increase beyond our boundaries
        while(index+((i+1)*(i+1)) < this.size-1 && this.hashTable[index+(i*i)] != value){
            this.numberOfCollisions++; //increment number of collisions
            i++; //increment i
        }

        //then return the value if we've found it, -1 otherwise
        try {
            return this.hashTable[index+(i*i)];
        } catch (Exception e) {
            return -1;
        }
    }
}
